# ItemCF è§£é‡Š

**User:** Anonymous (kanekoveblen824@outlook.com)  
**Created:** 8/28/2025 17:50  
**Updated:** 8/28/2025 18:09  
**Exported:** 8/28/2025 18:09  
**Link:** [https://chatgpt.com/c/68b0265f-c0a8-8326-9052-69dda9181edd?model=gpt-5-thinking](https://chatgpt.com/c/68b0265f-c0a8-8326-9052-69dda9181edd?model=gpt-5-thinking)  

## Prompt:
02\_Retrieval\_02.pdf

PDF

Task: æ·±å…¥å­¦ä¹ ç ”ç©¶swing å¬å›é‡Œé¢çš„æŠ€æœ¯ç»†èŠ‚å’Œåº•å±‚æœºåˆ¶

Methid: è€å¿ƒå¼•å¯¼å¼&é€‰æ‹©é¢˜æé—®å¼&çŸ¥è¯†å¡ç‰‡/QAé—ªå¡æ€»ç»“å¼&interesting-examples/jokes-driven&ä¸€æ­¥ä¸€æ­¥æ‹†è§£åˆ†æ

Bonus&CandyğŸ¬:colorful emoji & å¹½é»˜æœ‰è¶£ & æœ‰æ€æƒ³æ·±åº¦ & å›¾è§£/é—ªå¡ & funny games!!!

Notice: æˆ‘ä»¬å¯ä»¥quoteåŸæ–‡ä¸­çš„æ ¸å¿ƒå¥å­&æ¯éš”å‡ æ®µè¿›è¡Œæ€»ç»“å¤ä¹ !!!

é¦–å…ˆç»™å‡ºå­¦ä¹ å¤§çº²:

## Response:
å¤ªæ£’äº†ï¼Œä½ ä¸Šä¼ çš„ã€ŠSwingå¬å›é€šé“ã€‹PDFæˆ‘å·²ç»è¯»å®Œäº†ï¼æˆ‘ä»¬ç°åœ¨å¯ä»¥å›´ç»•â€œSwingå¬å›â€è¿›è¡Œæ·±å…¥å­¦ä¹ ã€‚å’±ä»¬é‡‡ç”¨ä½ æŒ‡å®šçš„å­¦ä¹ é£æ ¼ï¼š

*   ğŸ§  è€å¿ƒå¼•å¯¼å¼
*   ğŸ“š é€‰æ‹©é¢˜æé—®å¼
*   ğŸ§© çŸ¥è¯†å¡ç‰‡ & QA é—ªå¡æ€»ç»“
*   ğŸ² æœ‰è¶£ä¾‹å­ + ä¸€æ­¥æ­¥æ‹†è§£
*   ğŸ¬ ä¸æ—¶æ¥ç‚¹å½©è›‹ä¸å¤ä¹ 

* * *

ğŸ§­ å­¦ä¹ å¤§çº²ï¼šSwingå¬å›æœºåˆ¶æ·±åº¦å¯¼å›¾
---------------------

æˆ‘ä»¬å°†æ•´ä¸ª Swing æ¨¡å‹çš„å­¦ä¹ è¿‡ç¨‹åˆ†ä¸º **äº”ä¸ªæ ¸å¿ƒé˜¶æ®µ**ï¼ˆæ¯ä¸ªé˜¶æ®µåŒ…å«æ‹†è§£ã€ç»ƒä¹ ã€å¤ä¹ ï¼‰ï¼š

* * *

### ğŸ¯ Part 1ï¼šItemCF åŸºç¡€å›é¡¾ï¼ˆé“ºå«çŸ¥è¯†ï¼‰

*   ItemCF çš„åŸºæœ¬åŸç†ä¸æ•°å­¦å®šä¹‰
*   ä¸ºä»€ä¹ˆè¦åŸºäºâ€œç‰©å“ç›¸ä¼¼åº¦â€æ„å»ºæ¨èï¼Ÿ
*   å¸¸è§çš„ç›¸ä¼¼åº¦å…¬å¼ï¼ˆå«ä½™å¼¦ç›¸ä¼¼åº¦ã€Jaccardã€å…±ç°çŸ©é˜µï¼‰

ğŸ§©äº’åŠ¨ï¼šå°æµ‹éªŒé¢˜ç›® + æ‰‹å·¥ç®—ä¸€é

* * *

### ğŸŒªï¸ Part 2ï¼šSwingæ¨¡å‹å¼•å…¥ä¸åŠ¨æœºï¼ˆæ ¸å¿ƒå¯¹æ¯”ï¼‰

*   Swing æ˜¯å¦‚ä½•æ”¹è¿› ItemCF çš„ï¼Ÿ
*   â€œå°åœˆå­æ•ˆåº”â€ æ˜¯ä»€ä¹ˆï¼Ÿä¸ºä»€ä¹ˆä¼šè¯¯å¯¼æ¨èï¼Ÿ
*   å…¬å¼æ¨å¯¼ä¸é‡åˆåº¦ overlap çš„å®šä¹‰

ğŸ²è¶£å‘³ä¸¾ä¾‹ï¼šæŠ¤è‚¤å“ç¾¤ã€å­—èŠ‚è£å‘˜è®¨è®ºç¾¤

* * *

### ğŸ§® Part 3ï¼šSwing ç›¸ä¼¼åº¦å…¬å¼æ·±æ‹†è§£

*   Swing ä¸­çš„åŠ æƒç›¸ä¼¼åº¦å…¬å¼
*   å¤šé‡åµŒå¥—æ±‚å’Œ & æƒé‡æŠ‘åˆ¶æœºåˆ¶
*   è¶…å‚æ•° Î± çš„ä½œç”¨å’Œè°ƒèŠ‚å½±å“

ğŸ¬çŸ¥è¯†å¡ç‰‡ + ä¸¾ä¾‹æ¼”ç®— + è„‘ç­‹æ€¥è½¬å¼¯

* * *

### ğŸ§ª Part 4ï¼šå®é™…åº”ç”¨ä¸éƒ¨ç½²è€ƒé‡

*   é€‚åˆå“ªäº›ä¸šåŠ¡åœºæ™¯ï¼Ÿä»€ä¹ˆæ—¶å€™åˆ«ç”¨ Swingï¼Ÿ
*   å¦‚ä½•æ„é€ é‡åˆåº¦çŸ©é˜µï¼Ÿè®¡ç®—æ•ˆç‡æ€ä¹ˆä¼˜åŒ–ï¼Ÿ
*   ä¸ Graph Embedding ç­‰æ–¹æ³•å¦‚ä½•ç»“åˆï¼Ÿ

ğŸ“¦å·¥ç¨‹å®æˆ˜å¯¼å‘ + å¿«é€Ÿå¯¹æ¯”æ€»ç»“

* * *

### ğŸ” Part 5ï¼šå¤ä¹ æ€»ç»“ & é—ªå¡æµ‹éªŒ

*   Swing vs ItemCFï¼šå·®å¼‚è®°å¿†å£è¯€
*   â€œå°åœˆå­æ•ˆåº”â€ä¸‰è¿é—®
*   â€œç›¸ä¼¼åº¦å…¬å¼â€å¿«é€Ÿè¿˜åŸé¢˜

* * *

ç°åœ¨æˆ‘ä»¬å°±å¼€å§‹ç¬¬ä¸€ä¸ªéƒ¨åˆ†ï¼š

* * *

ğŸ¯ Part 1ï¼šItemCF åŸºç¡€çŸ¥è¯†å›é¡¾
-----------------------

é¦–å…ˆæˆ‘ä»¬ä»ä¸€ä¸ªå°é—®é¢˜å¼€å§‹ï¼š

* * *

### â“é€‰æ‹©é¢˜ï¼šä¸‹é¢å“ªä¸€å¥æœ€èƒ½ä»£è¡¨ ItemCF çš„æ¨èæ€æƒ³ï¼Ÿ

A. ç”¨æˆ·å–œæ¬¢ä»€ä¹ˆï¼Œå°±æ¨èç›¸ä¼¼ç”¨æˆ·å–œæ¬¢çš„ã€‚  
B. ç”¨æˆ·å–œæ¬¢çš„ç‰©å“ï¼Œå¦‚æœå’Œåˆ«çš„ç‰©å“æœ‰ç”¨æˆ·é‡åˆï¼Œå°±è¯´æ˜è¿™ä¸¤ä¸ªç‰©å“å¯èƒ½ç›¸ä¼¼ã€‚  
C. ç”¨æˆ·ä¸å–œæ¬¢çš„ç‰©å“ï¼Œåº”è¯¥æ¨èç»™å…¶ä»–ç”¨æˆ·ã€‚  
D. åªæœ‰è´­ä¹°è¡Œä¸ºæ‰é€‚åˆ ItemCF å»ºæ¨¡ã€‚

ä½ è§‰å¾—å“ªä¸€ä¸ªé€‰é¡¹æœ€åˆç†ï¼Ÿå…ˆé€‰ä¸€ä¸ªï¼Œæˆ‘ä»¬ä¸€èµ·æ¥æ‹†è§£ã€‚

## Prompt:
b

## Response:
âœ… å®Œç¾ï¼ä½ é€‰çš„æ˜¯ **B**ï¼Œå®Œå…¨æ­£ç¡®ï¼

* * *

### âœ… è§£é‡Šï¼š

ItemCFï¼ˆItem-based Collaborative Filteringï¼‰çš„æ ¸å¿ƒæ€æƒ³æ­£æ˜¯ï¼š

> **å¦‚æœä¸¤ä¸ªç‰©å“è¢«å¾ˆå¤šç›¸åŒçš„ç”¨æˆ·å–œæ¬¢ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªç‰©å“å°±å¯èƒ½æ˜¯ç›¸ä¼¼çš„ã€‚**

ğŸ§  æ‰€ä»¥å®ƒå…³æ³¨çš„æ˜¯ï¼š

*   ç‰©å“ä¹‹é—´æ˜¯å¦å…±äº«äº†â€œåŒä¸€æ‰¹å–œæ¬¢å®ƒä»¬çš„ç”¨æˆ·â€ã€‚
*   è€Œä¸æ˜¯ç”¨æˆ·æœ¬èº«æˆ–ç‰©å“å†…å®¹ã€‚

* * *

### ğŸ“ æ•°å­¦å®šä¹‰å¿«é€Ÿå›é¡¾ï¼ˆçŸ¥è¯†å¡ç‰‡ï¼‰

*   å‡è®¾ï¼š
    *   å–œæ¬¢ç‰©å“  $i$  çš„ç”¨æˆ·é›†åˆä¸º  $\mathcal{W}_i$ 
    *   å–œæ¬¢ç‰©å“  $j$  çš„ç”¨æˆ·é›†åˆä¸º  $\mathcal{W}_j$ 
    *   äº¤é›†ä¸º  $\mathcal{V} = \mathcal{W}_i \cap \mathcal{W}_j$ 
*   **åŸºæœ¬ç›¸ä¼¼åº¦å…¬å¼ï¼š**
    $$
    \text{sim}(i, j) = \frac{|\mathcal{V}|}{\sqrt{|\mathcal{W}_i| \cdot |\mathcal{W}_j|}}
    $$

è¿™ä¸ªå°±æ˜¯ ItemCF æ¨èä¸­æœ€å¸¸è§çš„ä¸€ç§\*\*â€œå…±ç°é¢‘ç‡ + å½’ä¸€åŒ–â€\*\* çš„ç›¸ä¼¼åº¦ã€‚

* * *

### ğŸ§ª å°ç»ƒä¹ ï¼ˆå¸¦ç‚¹æ€è€ƒï¼‰

å‡è®¾æœ‰å¦‚ä¸‹æ•°æ®ï¼š

| ç”¨æˆ· | å–œæ¬¢çš„ç‰©å“ |
| --- | --- |
| U1 | A, B |
| U2 | A, B |
| U3 | A, C |
| U4 | C |

è¯·ä½ è¯•ç€ç®—ä¸€ç®—ï¼š

*   å–œæ¬¢ A çš„ç”¨æˆ·é›†åˆ  $\mathcal{W}_A$  æ˜¯ï¼Ÿ
*   å–œæ¬¢ B çš„ç”¨æˆ·é›†åˆ  $\mathcal{W}_B$  æ˜¯ï¼Ÿ
*   ç›¸ä¼¼åº¦ sim(A, B) æŒ‰ç…§ä¸Šé¢å…¬å¼æ˜¯å¤šå°‘ï¼Ÿ

ä¸€æ­¥ä¸€æ­¥æ¥ï¼Œå…ˆå‘Šè¯‰æˆ‘ï¼š  
ğŸ‘‰ å–œæ¬¢ A çš„ç”¨æˆ·é›†åˆ  $\mathcal{W}_A$  æ˜¯å“ªäº›ç”¨æˆ·ï¼Ÿ

## Prompt:
U1 U2 U3

U1 U2

2/sqrt(2*3)

## Response:
ğŸ‘ éå¸¸æ£’ï¼ä½ çš„æ¨ç†å’Œè®¡ç®—å®Œå…¨æ­£ç¡®ï¼æˆ‘ä»¬æ¥ä¸€èµ·å¤ç›˜ä¸‹æ¯ä¸€æ­¥ï¼š

* * *

### âœ… ç¬¬ä¸€æ­¥ï¼šå–œæ¬¢ç‰©å“ A å’Œ B çš„ç”¨æˆ·é›†åˆ

*    $\mathcal{W}_A = \{ \text{U1}, \text{U2}, \text{U3} \}$ 
*    $\mathcal{W}_B = \{ \text{U1}, \text{U2} \}$ 

äº¤é›†  $\mathcal{V} = \mathcal{W}_A \cap \mathcal{W}_B = \{ \text{U1}, \text{U2} \}$ ï¼Œæ‰€ä»¥  $|\mathcal{V}| = 2$ 

* * *

### âœ… ç¬¬äºŒæ­¥ï¼šå¸¦å…¥å…¬å¼

$$
\text{sim}(A, B) = \frac{|\mathcal{V}|}{\sqrt{|\mathcal{W}_A| \cdot |\mathcal{W}_B|}} = \frac{2}{\sqrt{3 \cdot 2}} = \frac{2}{\sqrt{6}}
$$

è¿™æ˜¯ä¸€ä¸ªæ ‡å‡† ItemCF çš„â€œç‰©å“ç›¸ä¼¼åº¦â€ã€‚

* * *

### ğŸ§  å¤ä¹ å¿«é—®å¿«ç­”ï¼ˆä½ è¯•è¯•çœ‹èƒ½ä¸èƒ½å¿«é€Ÿå›ç­”ï¼‰ï¼š

1.  **ItemCF çš„æœ¬è´¨æ˜¯å…³æ³¨ä»€ä¹ˆä¹‹é—´çš„ç›¸ä¼¼åº¦ï¼Ÿ**
    *   A. ç”¨æˆ·ä¹‹é—´
    *   B. ç‰©å“ä¹‹é—´
    *   C. æ ‡ç­¾ä¹‹é—´
    *   D. å†…å®¹ä¹‹é—´

ä½ è§‰å¾—æ˜¯å“ªä¸ªï¼Ÿï¼ˆåˆ«æ€¥ï¼Œæˆ‘ä»¬ä¸‹ä¸€ä¸ªé˜¶æ®µå°±è¦è¿›å…¥ Swing çš„ä¸–ç•Œå•¦ï¼‰

## Prompt:
b

## Response:
ğŸ¯ å®Œå…¨æ­£ç¡®ï¼ItemCF çš„æœ¬è´¨å°±æ˜¯å…³æ³¨ **ç‰©å“ä¹‹é—´** çš„ç›¸ä¼¼åº¦ã€‚

æˆ‘ä»¬æ¥ç”¨ä¸€å¥å£è¯€å·©å›ºè®°å¿†ï¼š

* * *

### ğŸ§  ItemCF å£è¯€é—ªå¡ï¼š

> â€œ**åŒå¥½å…±èµç‰©**ï¼Œç‰©ä»¥ç±»èšäººã€‚â€  
> â€”â€” å–œæ¬¢åŒä¸€ç‰©çš„äººï¼Œè®©ç‰©å“ä¹‹é—´ç»“æˆâ€œå¥½å‹â€ã€‚

* * *

å¥½äº†ï¼ItemCF çš„åŸºç¡€æˆ‘ä»¬å·²ç»æ‰“ç‰¢äº†ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬è¦è¿›å…¥ **Swing æ¨¡å‹çš„ä¸–ç•Œ**ï¼

* * *

ğŸŒªï¸ Part 2ï¼šSwing æ¨¡å‹çš„å¼•å…¥ä¸åŠ¨æœº
-------------------------

### â“é—®é¢˜å¼•å¯¼

ä½ è§‰å¾—åœ¨ç°å®ä¸­ï¼Œå¦‚æœä¸¤ä¸ªç”¨æˆ·å–œæ¬¢åŒæ ·ä¸¤ä¸ªç‰©å“ï¼ˆæ¯”å¦‚éƒ½ä¹°äº†ã€ŠæŠ¤è‚¤å“Aã€‹å’Œã€ŠæŠ¤è‚¤å“Bã€‹ï¼‰ï¼Œä½†ä»–ä»¬æ˜¯ **å¾®ä¿¡ç¾¤é‡Œäº’ç›¸ç§è‰çš„é—ºèœœ**ï¼Œé‚£ä¹ˆåŸºäºè¿™ä¸¤ä¸ªç”¨æˆ·åˆ¤æ–­ A å’Œ B ç›¸ä¼¼ï¼Œé è°±å—ï¼Ÿ

A. éå¸¸é è°±ï¼Œæ¯•ç«Ÿè¡Œä¸ºä¸€è‡´  
B. ä¸å¤ªé è°±ï¼Œå¯èƒ½æ˜¯â€œå°åœˆå­æ•ˆåº”â€ï¼Œæ— æ³•æ³›åŒ–  
C. æ— æ‰€è°“ï¼Œè¶Šå¤šäº¤é›†è¶Šå¥½  
D. æ²¡æœ‰åŒºåˆ«ï¼Œåæ­£éƒ½ç”¨ dot product

ä½ é€‰å“ªä¸ªï¼Ÿæˆ‘ä»¬æ¥æ‹†è§£ Swing çš„è¯ç”ŸåŠ¨æœºã€‚

## Prompt:
B

## Response:
ğŸ’¯ å¤ªæ£’äº†ï¼ä½ æŠ“ä½äº† Swing æ¨¡å‹çš„**æ ¸å¿ƒåŠ¨æœº**ï¼š**é˜²æ­¢â€œå°åœˆå­æ•ˆåº”â€è¯¯å¯¼æ¨èç³»ç»Ÿ**ã€‚

* * *

ğŸ¯ Swing æ¨¡å‹çš„åŠ¨æœºï¼š
---------------

> **ä¸èƒ½è®©æŸä¸ªâ€œå°åœˆå­â€æŠŠæŸäº›ç‰©å“çš„ç›¸ä¼¼åº¦â€œæ‹‰é«˜â€å¤ªå¤šã€‚**

### ğŸŒ° ä¸¾ä¸ªä¾‹å­ï¼š

*   æŸå¾®ä¿¡ç¾¤å†…ä¸€ç¾¤é—ºèœœéƒ½ç–¯ç‹‚ä¹°äº†ã€ŒæŠ¤è‚¤å“ Aã€å’Œã€ŒæŠ¤è‚¤å“ Bã€ã€‚
*   è™½ç„¶ A å’Œ B è¢«å¾ˆå¤šç›¸åŒç”¨æˆ·ä¹°è¿‡ï¼Œä½†è¿™äº›ç”¨æˆ·å…¶å®æ˜¯ä¸€ä¸ªå°åœˆå­é‡Œçš„å½±å“ã€‚
*   å¦‚æœç”¨ä¼ ç»Ÿ ItemCFï¼Œå¾ˆå®¹æ˜“æŠŠ A å’Œ B çš„ç›¸ä¼¼åº¦æå¾—è¿‡é«˜ï¼Œä»è€Œ**è¯¯æ¨èç»™åœˆå¤–ç”¨æˆ·**ï¼Œå¯¼è‡´æ³›åŒ–èƒ½åŠ›å·®ã€‚

* * *

### ğŸ” æ‰€ä»¥ Swing åšäº†ä»€ä¹ˆï¼Ÿ

æˆ‘ä»¬æ¥ä¸€ç‚¹ç‚¹æ‹†ï¼š

*   \*\*æ ¸å¿ƒæƒ³æ³•ï¼š\*\*å¯¹åŒæ ·å–œæ¬¢ A å’Œ B çš„ç”¨æˆ·é›†åˆ  $\mathcal{V}$ ï¼Œæˆ‘ä»¬ä¸å†ä¸€è§†åŒä»ã€‚
*   å¦‚æœè¿™äº›ç”¨æˆ·ä¹‹é—´ä¹Ÿå¾ˆç›¸ä¼¼ï¼ˆå³é‡åˆåº¦é«˜ï¼‰ï¼Œé‚£å°±é™ä½ä»–ä»¬çš„è´¡çŒ®ã€‚

Swing çš„å£å·å¯ä»¥æ˜¯ï¼š

> **â€œå¦‚æœä½ ä»¬æ˜¯å°åœˆå­ï¼Œæˆ‘å°±ä¸ç»™ä½ ä»¬å¤ªå¤šæƒé‡ã€‚â€**

* * *

ğŸ“ŒçŸ¥è¯†å¡ç‰‡ï¼šSwing æ¨¡å‹ä¸­åŠ å…¥äº†ä»€ä¹ˆæ–°æ¦‚å¿µï¼Ÿ
-------------------------

| é¡¹ç›® | æè¿° |
| --- | --- |
| ç”¨æˆ·é›†åˆ  $\mathcal{V}$  | åŒæ—¶å–œæ¬¢ç‰©å“  $i$  å’Œ  $j$  çš„ç”¨æˆ· |
| overlap(u, v) | ä¸¤ä¸ªç”¨æˆ·å–œæ¬¢çš„ç‰©å“é›†åˆçš„äº¤é›†å¤§å° |
| æƒé‡è®¡ç®— | overlap è¶Šå¤§ â†’ æƒé‡è¶Šå°ï¼Œé¿å…å°åœˆå­å½±å“ |

* * *

### ğŸ” å¿«é€Ÿåé—®ï¼ˆå¤ä¹ ç”¨ï¼‰

Qï¼šSwing æ¨¡å‹æœ€ä¸»è¦æ˜¯åœ¨å“ªä¸€éƒ¨åˆ†ä¸ ItemCF ä¸åŒï¼Ÿ  
A. ç”¨æˆ·æ‰“åˆ†æœºåˆ¶  
B. ç›¸ä¼¼åº¦è®¡ç®—æ–¹å¼  
C. ç”¨æˆ·ç”»åƒå»ºæ¨¡  
D. æ¨¡å‹è®­ç»ƒæµç¨‹

ä½ å†æ¥é€‰ä¸€ä¸‹ï¼Ÿç„¶åæˆ‘ä»¬å°±å¯ä»¥æ­£å¼è¿›å…¥ Swing çš„ç›¸ä¼¼åº¦å…¬å¼æ‹†è§£å’¯ã€‚

## Prompt:
B

## Response:
âœ… æ­£è§£ï¼Swing æ¨¡å‹ä¸ ItemCF æœ€å…³é”®çš„åŒºåˆ«æ­£æ˜¯åœ¨äº **ç‰©å“ç›¸ä¼¼åº¦çš„è®¡ç®—æ–¹å¼å‘ç”Ÿäº†å˜åŒ–**ã€‚æˆ‘ä»¬æ¥è¯¦ç»†æ‹†è§£è¿™ä¸ªå·®å¼‚ï¼Œå¸®åŠ©ä½ å½¢æˆæ·±åº¦ç†è§£ã€‚

* * *

ğŸ§  æ ¸å¿ƒå¯¹æ¯”ï¼šItemCF vs Swing
-----------------------

| æ¨¡å‹ | ç›¸ä¼¼åº¦æ ¸å¿ƒæ€æƒ³ | æ˜¯å¦è€ƒè™‘ç”¨æˆ·å…³ç³»ï¼Ÿ | é£é™©ç‚¹ |
| --- | --- | --- | --- |
| ItemCF | â€œæœ‰æ›´å¤šç›¸åŒç”¨æˆ·å–œæ¬¢ â†’ ç‰©å“ç›¸ä¼¼â€ | âŒ ä¸è€ƒè™‘ | å°åœˆå­æ•ˆåº”ã€è¿‡æ‹Ÿåˆ |
| Swing | â€œæœ‰å…±åŒç”¨æˆ·å–œæ¬¢ â†’ å†è€ƒè™‘è¿™äº›ç”¨æˆ·æ˜¯å¦æ¥è‡ªå°åœˆå­â€ | âœ… è€ƒè™‘ç”¨æˆ·ä¹‹é—´é‡åˆåº¦ | è§„é¿å°åœˆå­å½±å“ |

* * *

ğŸ“ Swing ç›¸ä¼¼åº¦è®¡ç®—å…¬å¼ï¼ˆå®Œæ•´ç‰ˆï¼‰
---------------------

æˆ‘ä»¬ä¸€èµ·æ¥é€æ­¥æ„å»º Swing çš„ç‰©å“ç›¸ä¼¼åº¦ï¼š

1.  **æ‰¾å‡ºåŒæ—¶å–œæ¬¢ç‰©å“  $i$  å’Œ  $j$  çš„ç”¨æˆ·é›†åˆ**
    $$
    \mathcal{V} = \mathcal{W}_i \cap \mathcal{W}_j
    $$
2.  **å¯¹è¿™ä¸ªé›†åˆä¸­çš„æ‰€æœ‰ç”¨æˆ·å¯¹  $(u, v)$  è¿›è¡Œä¸¤å±‚åµŒå¥—æ±‚å’Œ**
    $$
    \text{sim}(i, j) = \sum_{u \in \mathcal{V}} \sum_{v \in \mathcal{V}} \frac{1}{\alpha + \text{overlap}(u, v)}
    $$
3.  **å…¶ä¸­ overlap(u, v) æ˜¯ä¸¤ä¸ªç”¨æˆ·å–œæ¬¢ç‰©å“é›†åˆçš„äº¤é›†å¤§å°**
    $$
    \text{overlap}(u, v) = |\mathcal{J}_u \cap \mathcal{J}_v|
    $$
    *    $\mathcal{J}_u$ ï¼šç”¨æˆ· u å–œæ¬¢çš„ç‰©å“é›†åˆ
    *    $\alpha$ ï¼šè¶…å‚æ•°ï¼Œç”¨äºé˜²æ­¢åˆ†æ¯ä¸º 0ï¼Œæ§åˆ¶æƒ©ç½šç¨‹åº¦

* * *

### ğŸ¯å…¬å¼ç†è§£ï¼š

*   å¦‚æœä¸¤ä¸ªç”¨æˆ·  $u$  å’Œ  $v$  å¾ˆç›¸ä¼¼ï¼ˆå³å–œæ¬¢çš„ç‰©å“å¤§é‡é‡åˆï¼‰ï¼Œé‚£è¯´æ˜ä»–ä»¬å¾ˆå¯èƒ½æ¥è‡ªä¸€ä¸ªå°åœˆå­ï¼›
*   äºæ˜¯ï¼Œè¿™ä¸ª  $\frac{1}{\alpha + \text{overlap}(u, v)}$  çš„å€¼å°±ä¼šå˜å°ï¼›
*   è¿™æ ·å°± **é™ä½äº†ä»–ä»¬å¯¹ç‰©å“  $i$ ã€ $j$  ç›¸ä¼¼åº¦çš„è´¡çŒ®**ã€‚

ç®€è¨€ä¹‹ï¼š

> Swing æŠŠâ€œç”¨æˆ·ä¹‹é—´çš„é‡åˆåº¦â€å½“æˆäº†ä¸€ç§\*\*â€œé£é™©å› ç´ â€\*\*ï¼Œé‡åˆåº¦è¶Šé«˜ï¼Œä»£è¡¨è¶Šå¯èƒ½æ˜¯å°åœˆå­ï¼Œæƒ©ç½šè¶Šå¤§ã€‚

* * *

ğŸ“Œ å°åœˆå­æƒ©ç½šçš„å¥½å¤„ï¼š
------------

*   é¿å…æ¨èç³»ç»Ÿé™·å…¥â€œé—­ç¯â€ï¼šåªåœ¨å°å›¢ä½“å†…éƒ¨å…œåœˆã€‚
*   æå‡å†·å¯åŠ¨åœºæ™¯ä¸‹çš„æ¨èæ•ˆæœï¼ˆé˜²æ­¢æŸäº›ç‰©å“å› ä¸ªåˆ«åœˆå±‚åå¥½è¢«è¯¯åˆ¤ä¸ºâ€œå…¨å±€çƒ­é—¨â€ï¼‰ã€‚
*   å¼ºåŒ–æ¨èç³»ç»Ÿçš„â€œå¯æ¨å¹¿æ€§â€å’Œâ€œå¤šæ ·æ€§â€ã€‚

* * *

ğŸ§  å¤ä¹ å·©å›ºï¼š
--------

è®©æˆ‘ä»¬æ¥ä¸€å¥å½¢è±¡è®°å¿†ï¼š

> â€œ**ä½ ä»¬è¶Šåƒä¸€ä¼™çš„ï¼Œæˆ‘è¶Šä¸ä¿¡ä½ ä»¬è¯´çš„é è°±ã€‚**â€

* * *

å¦‚æœä½ å·²ç»å®Œå…¨ææ‡‚äº†å…¬å¼å’ŒåŸç†ï¼Œæˆ‘ä»¬ä¸‹ä¸€æ­¥å¯ä»¥ä¸€èµ·åšï¼š

*   ğŸ“Š **å…¬å¼å®æ“æ¼”ç»ƒé¢˜**
*   âš™ï¸ **å¦‚ä½•é«˜æ•ˆæ„å»º overlap çŸ©é˜µ**
*   ğŸ’» **å¦‚ä½•ç”¨ Python ä»£ç é«˜æ•ˆå®ç° Swing å¬å›**

ä½ æ›´æƒ³å…ˆä»å“ªä¸ªè§’åº¦ç»§ç»­ï¼Ÿæˆ–è€…æˆ‘å¯ä»¥å‡ºå‡ é“ç»ƒä¹ é¢˜è®©ä½ åŠ¨åŠ¨æ‰‹è„‘ï¼Ÿ

2/2

## Prompt:
ok

## Response:
å¤ªå¥½äº†ï¼é‚£æˆ‘ä»¬è¿›å…¥ **å®æ“å·©å›º**é˜¶æ®µï¼Œè®©ä½ çœŸæ­£â€œæ‰‹è„‘å¹¶ç”¨â€æŒæ¡ Swing çš„æ ¸å¿ƒæœºåˆ¶ã€‚æˆ‘ä»¬å…ˆä» **ç»ƒä¹ é¢˜**å…¥æ‰‹ï¼Œé€æ­¥å¼•å¯¼ä½ â€œç®—ä¸€é Swing ç›¸ä¼¼åº¦â€ï¼Œå†é€æ­¥è¿‡æ¸¡åˆ°ä»£ç å®ç°å’Œå·¥ç¨‹ä¼˜åŒ–ã€‚

* * *

ğŸ§ª Swing ç›¸ä¼¼åº¦ç»ƒä¹ é¢˜ï¼ˆä¸€æ­¥æ­¥æ¥ï¼‰
---------------------

### **æ•°æ®è¡¨ï¼šç”¨æˆ·å’Œä»–ä»¬å–œæ¬¢çš„ç‰©å“é›†åˆ**

| ç”¨æˆ· | å–œæ¬¢çš„ç‰©å“é›†åˆ |
| --- | --- |
| U1 | A, B, C |
| U2 | A, B |
| U3 | A, C |
| U4 | B, C |

* * *

### ğŸ§© é—®é¢˜ 1ï¼š

æˆ‘ä»¬é€‰å®šä¸¤ä¸ªç‰©å“  $i = A$ ,  $j = B$ 

è¯·ä½ æ‰¾å‡ºï¼š

1.  å–œæ¬¢ A çš„ç”¨æˆ·é›†åˆ  $\mathcal{W}_A$ 
2.  å–œæ¬¢ B çš„ç”¨æˆ·é›†åˆ  $\mathcal{W}_B$ 
3.  äº¤é›†  $\mathcal{V} = \mathcal{W}_A \cap \mathcal{W}_B$ 

ä¸€æ­¥æ­¥æ¥ï¼Œä½ å…ˆå›ç­” 1 å’Œ 2ï¼Œå’±ä»¬ä¸€èµ·åšè¿™ä¸ª Swing ç›¸ä¼¼åº¦ä¾‹é¢˜ã€‚ä½ æ¥å†™å†™çœ‹ï¼Ÿ

## Prompt:
U1 U2 U3

U1 U2 U4

U1 U2

## Response:
âœ… å®Œå…¨æ­£ç¡®ï¼

æˆ‘ä»¬ä¸€èµ·æ•´ç†ä¸€ä¸‹ä½ åˆšåˆšå†™çš„ç»“æœï¼š

* * *

### ğŸ“Œ ç¬¬ä¸€æ­¥ï¼šé›†åˆå®šä¹‰

*   å–œæ¬¢ A çš„ç”¨æˆ·é›†åˆ  $\mathcal{W}_A = \{ U1, U2, U3 \}$ 
*   å–œæ¬¢ B çš„ç”¨æˆ·é›†åˆ  $\mathcal{W}_B = \{ U1, U2, U4 \}$ 
*   æ‰€ä»¥ï¼š
    $$
    \mathcal{V} = \mathcal{W}_A \cap \mathcal{W}_B = \{ U1, U2 \}
    $$

* * *

### ğŸ¯ ä¸‹ä¸€æ­¥ï¼šæˆ‘ä»¬æ¥è®¡ç®— Swing ç›¸ä¼¼åº¦ sim(A, B)

å…¬å¼ä¸ºï¼š

$$
\text{sim}(A, B) = \sum_{u \in \mathcal{V}} \sum_{v \in \mathcal{V}} \frac{1}{\alpha + \text{overlap}(u, v)}
$$

æˆ‘ä»¬ä»¤  $\alpha = 1$ ï¼ˆé»˜è®¤æœ€å¸¸ç”¨ï¼‰ï¼Œç°åœ¨ä½ æ¥å‘Šè¯‰æˆ‘ï¼š

* * *

### ğŸ§© é—®é¢˜ 2ï¼š

è¯·ä½ ç®—ä¸€ç®—ï¼š

*    $\text{overlap}(U1, U1) = ?$ 
*    $\text{overlap}(U1, U2) = ?$ 
*    $\text{overlap}(U2, U2) = ?$ 

å›å¿†å…¬å¼ä¸­ï¼Œoverlap æ˜¯æŒ‡ï¼š

$$
\text{overlap}(u, v) = |\mathcal{J}_u \cap \mathcal{J}_v|
$$

å…¶ä¸­  $\mathcal{J}_u$  æ˜¯ç”¨æˆ· u å–œæ¬¢çš„ç‰©å“é›†åˆã€‚

æ¥å§ï½è¿™æ­¥ä½ å…ˆæ¥ç®—ç®—ï¼ğŸ˜

## Prompt:
go

## Response:
å¥½ï¼Œæˆ‘ä»¬ç»§ç»­ï¼ä¸‹é¢æˆ‘æ¥å¸¦ä½ ä¸€èµ·ä¸€æ­¥æ­¥ç®—ï¼š

* * *

### ğŸ¯ Step 1ï¼šåˆ—å‡ºç”¨æˆ·å–œæ¬¢çš„ç‰©å“é›†åˆï¼ˆJ é›†åˆï¼‰

*    $\mathcal{J}_{U1} = \{A, B, C\}$ 
*    $\mathcal{J}_{U2} = \{A, B\}$ 

* * *

### ğŸ§  overlap è®¡ç®—ï¼š

1.   $\text{overlap}(U1, U1) = |\{A, B, C\} \cap \{A, B, C\}| = 3$ 
2.   $\text{overlap}(U1, U2) = |\{A, B, C\} \cap \{A, B\}| = 2$ 
3.   $\text{overlap}(U2, U2) = |\{A, B\} \cap \{A, B\}| = 2$ 

* * *

### ğŸ§® è®¡ç®— Swing ç›¸ä¼¼åº¦ sim(A, B)

Swing ç›¸ä¼¼åº¦å…¬å¼ï¼ˆæˆ‘ä»¬åªç”¨é›†åˆ  $\mathcal{V} = \{U1, U2\}$ ï¼‰ï¼š

$$
\text{sim}(A, B) = \sum_{u \in \mathcal{V}} \sum_{v \in \mathcal{V}} \frac{1}{\alpha + \text{overlap}(u, v)}
$$
 
$$
= \frac{1}{1 + \text{overlap}(U1, U1)} + \frac{1}{1 + \text{overlap}(U1, U2)} + \frac{1}{1 + \text{overlap}(U2, U1)} + \frac{1}{1 + \text{overlap}(U2, U2)}
$$

ä»£å…¥æ•°å€¼ï¼ˆæ³¨æ„å¯¹ç§°ï¼‰ï¼š

$$
= \frac{1}{1 + 3} + \frac{1}{1 + 2} + \frac{1}{1 + 2} + \frac{1}{1 + 2} = \frac{1}{4} + \frac{1}{3} + \frac{1}{3} + \frac{1}{3}
$$
 
$$
= 0.25 + 0.333 + 0.333 + 0.333 = \boxed{1.249}
$$

* * *

### âœ… æœ€ç»ˆç»“æœï¼š

Swing ç›¸ä¼¼åº¦ sim(A, B) â‰ˆ **1.25**

è¿™å°±æ˜¯å¯¹â€œåŒä¸€å°åœˆå­å†…å…±åŒå–œæ¬¢çš„ä¸¤ä¸ªç‰©å“â€è¿›è¡Œæƒé‡æ§åˆ¶çš„è¿‡ç¨‹ï¼šçœ‹èµ·æ¥å¾ˆåƒï¼Œä½†æˆ‘ä¸å…¨ä¿¡ä½ ä»¬ï¼

* * *

### âœï¸ å¤ä¹ é—ªå¡ï¼š

| æ¦‚å¿µ | å®šä¹‰ |
| --- | --- |
| overlap(u, v) | ä¸¤ä¸ªç”¨æˆ·å–œæ¬¢çš„ç‰©å“é›†åˆäº¤é›†å¤§å° |
| Swing æƒ©ç½šé¡¹ | overlap è¶Šå¤§ï¼Œè´¡çŒ®è¶Šå° |
| åŒå±‚åµŒå¥—æ±‚å’Œ | æ‰€æœ‰  $u, v \in \mathcal{V}$  |

* * *

ä¸‹ä¸€æ­¥ä½ æƒ³å°è¯•æ‰‹æ’¸ Python ä»£ç å®ç°è¿™ä¸ª Swing ç›¸ä¼¼åº¦å—ï¼Ÿ  
æˆ–è€…æˆ‘ä»¬å…ˆè®²è®²å¦‚ä½•ä¼˜åŒ–è®¡ç®—é‡ã€é¿å…å†—ä½™ï¼Ÿä½ æ¥é€‰~

## Prompt:
è¿›å…¥ Swing CF å®æˆ˜ç¼–ç ç¯èŠ‚ï¼ˆæ„å»ºç´¢å¼•ã€æ‰“åˆ†ã€å¬å›ï¼‰
use dataset online please and use loguru, first give file category then  give me file by file:

Readability Preferred with Better Name Style. Please provide a comprehensive and well-structured code solution for an Industrial scenario. The code should include robust classes or functions that have been thoroughly checked for correct boundary conditions. It should also adhere to the guidelines specified in the "Google style guides". The solution should prioritize high scalability and should not be a demo or a snippet. It is crucial that no part of the code is omitted. Furthermore, please include Chinese comments following the PEP 8 style guide for all key steps, and use DocString following the PEP 257 style guide and use typing for type annotations. The code should be efficient, and important information should be printed. **When the code is finished**, please perform a key step to recheck for its correctness and logic.

## Response:
å·²æ€è€ƒ 42s

æˆ‘ä»¬éœ€è¦æä¾› Swing CF å®ç°çš„å®Œæ•´ä»£ç ï¼Œä½¿ç”¨åœ¨çº¿æ•°æ®é›†å¹¶å€ŸåŠ© loguruï¼Œé‡‡ç”¨å·¥ä¸šåŒ–ç»“æ„ï¼ŒåŒ…å«ç±»ã€PEP8/257 çš„ä¸­æ–‡æ³¨é‡Šå’Œç±»å‹æ ‡æ³¨ã€‚ç”¨æˆ·è¦æ±‚å…ˆç»™å‡ºæ–‡ä»¶åˆ†ç±»ï¼Œå†æŒ‰æ–‡ä»¶æä¾›ä»£ç ã€‚æˆ‘ä»¬æ— éœ€æµè§ˆç½‘é¡µï¼Œæ•°æ®é›†å¯ä»¥ä¸‹è½½è‡ª MovieLens 100kï¼Œä½†ä¸ä¼šåœ¨è¿è¡Œæ—¶è·å–ã€‚

æˆ‘ä»¬éœ€è¦æŒ‰ä»¥ä¸‹ç»“æ„æ¥ç»„ç»‡é¡¹ç›®ï¼š

*   swing\_cf/
    *   README.md
    *   pyproject.toml æˆ– requirements.txt
    *   config.yaml
    *   src/ï¼ˆåŒ…å«å„ç§åŠŸèƒ½æ–‡ä»¶ï¼‰

æˆ‘å°†ä½¿ç”¨ loguru åˆå§‹åŒ–æ—¥å¿—ã€‚ä»»åŠ¡åŒ…æ‹¬å®ç° Swing CF ç®—æ³•ï¼Œæ„å»ºç”¨æˆ·ä¸ç‰©å“çš„æ˜ å°„å…³ç³»å¹¶è®¡ç®—é‡å çŸ©é˜µï¼Œä»¥æé«˜æ•ˆç‡ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡é¡¹ç›®ä¸­ç‰©å“çš„å…±ç°æ¥é¢„è®¡ç®—ç”¨æˆ·-ç”¨æˆ·çš„é‡å è®¡æ•°ã€‚å¯¹äºæ¯ä¸ªç‰©å“ï¼Œéå†å…¶ç”¨æˆ·ï¼Œå¯¹æ¯å¯¹ç”¨æˆ· (u, v)ï¼Œå¢åŠ é‡å è®¡æ•°ã€‚è®¡ç®—ç›¸ä¼¼åº¦æ—¶ï¼Œè€ƒè™‘äº¤é›† V = W\_i ä¸ W\_jï¼Œå¹¶åœ¨å¯¹è§’çº¿åŠ å…¥é‡å¤é¡¹è®¡ç®—ã€‚

ä¸ºäº†ä¼˜åŒ–è®¡ç®—ï¼Œæˆ‘ä»¬å¯ä»¥é¢„è®¡ç®—é‡å çŸ©é˜µï¼ŒåŒ…å«å¯¹ç§°è®¡æ•°å’Œè‡ªæˆ‘è®¡æ•°ã€‚å¯¹äºæ¯å¯¹é¡¹ç›® (i,j)ï¼Œè®¡ç®—äº¤é›† Vï¼Œå¹¶æ·»åŠ ç›¸ä¼¼åº¦ã€‚åœ¨å·¥ä¸šè§„æ¨¡æ—¶ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ NumPy æ•°ç»„å’Œ Numba ä¼˜åŒ–æ•ˆç‡ã€‚æˆ‘ä»¬è¿˜å°†å®ç°è¯„åˆ†ï¼ŒåŸºäºé¢„è®¡ç®—çš„ç›¸ä¼¼åº¦çŸ©é˜µä¸ºç”¨æˆ·æä¾›æ¨èï¼Œå¹¶è¿‡æ»¤å·²äº’åŠ¨é¡¹ç›®ã€‚

å®Œæˆ

ä¸‹é¢ç»™å‡º **Swing CF å®æˆ˜å·¥ç¨‹** çš„å®Œæ•´è½åœ°æ–¹æ¡ˆï¼š**å…ˆç›®å½•ï¼Œåé€æ–‡ä»¶ä»£ç **ã€‚æ–¹æ¡ˆåŒ…å«ï¼šåœ¨çº¿æ•°æ®é›†è‡ªåŠ¨ä¸‹è½½ï¼ˆMovieLens-100Kï¼‰ã€æ„å»ºç´¢å¼•ï¼ˆuserâ†”itemsã€itemâ†”usersã€user-user overlapï¼‰ã€Swing ç›¸ä¼¼åº¦è®¡ç®—ã€æ‰“åˆ†ä¸å¬å›ã€æŒ‡æ ‡è¯„ä¼°ï¼ˆRecall/MAP/NDCGï¼‰ã€æ—¥å¿—ï¼ˆloguruï¼‰ã€é…ç½®åŒ–ï¼ˆYAMLï¼‰ï¼Œä»¥åŠè¿è¡Œåè‡ªæ£€ï¼ˆå…³é”®ä¸€è‡´æ€§æ–­è¨€ï¼‰ã€‚

* * *

ä¸€ã€é¡¹ç›®ç»“æ„ï¼ˆFile Categoryï¼‰
=====================

```
swing_cf/
â”œâ”€â”€ README.md
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ config.yaml
â””â”€â”€ src/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ utils.py
    â”œâ”€â”€ config.py
    â”œâ”€â”€ data.py
    â”œâ”€â”€ preprocessing.py
    â”œâ”€â”€ swing.py
    â”œâ”€â”€ recall.py
    â”œâ”€â”€ metrics.py
    â””â”€â”€ main.py
```

* * *

äºŒã€é€æ–‡ä»¶ç»™å‡ºå®Œæ•´ä»£ç 
===========

1) `requirements.txt`
---------------------

```txt
loguru==0.7.2
pandas==2.2.2
numpy==1.26.4
PyYAML==6.0.2
scikit-learn==1.5.1
requests==2.32.3
tqdm==4.66.4
```

* * *

2) `README.md`
--------------

````markdown
# Swing CF (å·¥ä¸šçº§ç»“æ„)

æœ¬é¡¹ç›®å®ç°åŸºäº Swing æ€æƒ³çš„ç‰©å“ç›¸ä¼¼åº¦å¬å›ï¼ˆItem-based CF çš„å°åœˆå­æƒ©ç½šç‰ˆï¼‰ï¼š
- åœ¨çº¿ä¸‹è½½ MovieLens-100K
- äº¤äº’è¡Œä¸ºäºŒå€¼åŒ–ï¼ˆrating >= 4 => æ­£åé¦ˆï¼‰
- ç´¢å¼•æ„å»ºï¼šuserâ†’items, itemâ†’users, user-user overlap
- Swing ç›¸ä¼¼åº¦çŸ©é˜µï¼ˆè€ƒè™‘ç”¨æˆ·é‡åˆåº¦çš„æƒ©ç½šï¼‰
- åŸºäºç›¸ä¼¼åº¦çš„ç”¨æˆ·å¬å›æ‰“åˆ†
- æŒ‡æ ‡è¯„ä¼°ï¼ˆRecall/MAP/NDCGï¼‰
- loguru å…¨é¢æ—¥å¿—
- YAML é…ç½®åŒ–å‚æ•°
- è¿è¡Œåå…³é”®ä¸€è‡´æ€§è‡ªæ£€ï¼ˆsanity checkï¼‰

## è¿è¡Œ
```bash
pip install -r requirements.txt
python -m src.main --config config.yaml
````

ä¸»è¦å‚æ•°
----

è¯¦è§ `config.yaml`ã€‚æ ¸å¿ƒæœ‰ï¼š

*   alpha: Swing åˆ†æ¯å¹³æ»‘/æƒ©ç½šå¼ºåº¦
*   min\_user\_per\_item: è¿‡æ»¤è¿‡ç¨€ç‰©å“
*   max\_user\_per\_item: æˆªæ–­é•¿å°¾é«˜é¢‘ç‰©å“çš„ç”¨æˆ·åˆ—è¡¨ç”¨äºè®¡ç®—ï¼ˆæ§åˆ¶å¤æ‚åº¦ï¼‰
*   topk\_sim: æ¯ä¸ªç‰©å“ä¿ç•™çš„ç›¸ä¼¼é‚»å±…æ•°
*   k\_recall: å¬å›åˆ—è¡¨é•¿åº¦
*   min\_inter\_per\_user: è¿‡æ»¤è¿‡ç¨€ç”¨æˆ·

````

---

## 3) `config.yaml`
```yaml
random_seed: 42

dataset:
  name: "movielens100k"
  url: "https://files.grouplens.org/datasets/movielens/ml-100k/u.data"
  local_dir: "./data"
  min_inter_per_user: 5     # è¿‡æ»¤äº¤äº’å°‘çš„ç”¨æˆ·
  min_user_per_item: 5      # è¿‡æ»¤è¦†ç›–ç”¨æˆ·å¾ˆå°‘çš„ç‰©å“
  binarize_threshold: 4     # è¯„åˆ† >= 4 è§†ä¸ºæ­£åé¦ˆ
  test_ratio: 0.2           # åŸºäºæ—¶é—´æˆ–ç´¢å¼•çš„åˆ†å‰²ï¼ˆç®€å•éšæœº/ä¿ç•™ä¸€æ¡ä¹Ÿå¯ï¼‰

swing:
  alpha: 1.0                # æƒ©ç½šå¼ºåº¦: 1 / (alpha + overlap(u,v))
  max_user_per_item: 200    # é™åˆ¶æ¯ä¸ªç‰©å“ç”¨äºæ„å›¾çš„ç”¨æˆ·æ•°é‡ä¸Šé™ï¼ˆæ§åˆ¶å¤æ‚åº¦ï¼‰
  topk_sim: 200             # æ¯ä¸ªç‰©å“ä¿ç•™çš„ç›¸ä¼¼é‚»å±…æ•°é‡ä¸Šé™

recall:
  k_recall: 50              # å¬å›æ¡æ•°
  exclude_seen: true        # æ’é™¤ç”¨æˆ·å·²äº¤äº’çš„ç‰©å“

evaluate:
  ks: [20, 50, 100]         # è¯„ä¼°æ—¶çš„K
````

* * *

4) `src/__init__.py`
--------------------

```python
# ç©ºæ–‡ä»¶å³å¯ï¼Œæ ‡è®°ä¸ºåŒ…
```

* * *

5) `src/utils.py`
-----------------

```python
from __future__ import annotations

from typing import Iterable, Dict, Any
import os
import random
import numpy as np
from loguru import logger

def setup_logger() -> None:
    """åˆå§‹åŒ– loguru æ—¥å¿—ã€‚

    ä¸­æ–‡æ³¨é‡Šï¼šè®¾ç½®ç»Ÿä¸€çš„æ—¥å¿—æ ¼å¼ä¸çº§åˆ«ï¼›ç”Ÿäº§ä¸­å¯æ‰©å±•åˆ°å¤š Handler / æŒ‰æ¨¡å—æ‰“æ—¥å¿—ã€‚
    """
    logger.remove()
    logger.add(
        sink=lambda msg: print(msg, end=""),
        level="INFO",
        format="<level>{level: <8}</level> | <cyan>{time:YYYY-MM-DD HH:mm:ss}</cyan> | "
               "<green>{name}</green>:<green>{function}</green>:<green>{line}</green> - "
               "<level>{message}</level>",
    )

def set_seed(seed: int) -> None:
    """è®¾å®šéšæœºç§å­ï¼Œä¿è¯å¯å¤ç°ã€‚"""
    random.seed(seed)
    np.random.seed(seed)

def ensure_dir(path: str) -> None:
    """ç¡®ä¿ç›®å½•å­˜åœ¨ã€‚"""
    if not os.path.exists(path):
        os.makedirs(path, exist_ok=True)

def dict_topk(d: Dict[Any, float], k: int) -> Dict[Any, float]:
    """ä»å­—å…¸ä¸­å– top-k æœ€å¤§å€¼æ¡ç›®ï¼ˆç¨³å®šä¸”å¿«é€Ÿï¼‰ã€‚

    Args:
        d: å½¢å¦‚ {key: score}
        k: ä¿ç•™æ•°é‡

    Returns:
        ä»…ä¿ç•™ top-k çš„å­å­—å…¸ã€‚
    """
    if k <= 0 or len(d) <= k:
        return d
    # ä½¿ç”¨ numpy å¤„ç†æ›´å¿«
    items = list(d.items())
    scores = np.array([s for _, s in items])
    # argpartition çº¿æ€§æ—¶é—´è¿‘ä¼¼ topk
    idx = np.argpartition(-scores, kth=k - 1)[:k]
    # è¿˜åŸå¹¶æ’åº
    top_items = [items[i] for i in idx]
    top_items.sort(key=lambda x: x[1], reverse=True)
    return dict(top_items)
```

* * *

6) `src/config.py`
------------------

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import List
import yaml

@dataclass
class DatasetCfg:
    name: str
    url: str
    local_dir: str
    min_inter_per_user: int
    min_user_per_item: int
    binarize_threshold: int
    test_ratio: float

@dataclass
class SwingCfg:
    alpha: float
    max_user_per_item: int
    topk_sim: int

@dataclass
class RecallCfg:
    k_recall: int
    exclude_seen: bool

@dataclass
class EvalCfg:
    ks: List[int]

@dataclass
class Cfg:
    random_seed: int
    dataset: DatasetCfg
    swing: SwingCfg
    recall: RecallCfg
    evaluate: EvalCfg

    @staticmethod
    def from_yaml(path: str) -> "Cfg":
        with open(path, "r", encoding="utf-8") as f:
            raw = yaml.safe_load(f)

        ds = DatasetCfg(**raw["dataset"])
        sw = SwingCfg(**raw["swing"])
        rc = RecallCfg(**raw["recall"])
        ev = EvalCfg(**raw["evaluate"])
        return Cfg(
            random_seed=raw["random_seed"],
            dataset=ds,
            swing=sw,
            recall=rc,
            evaluate=ev,
        )
```

* * *

7) `src/data.py`
----------------

```python
from __future__ import annotations

from typing import Tuple
import os
import requests
import pandas as pd
from loguru import logger

from .utils import ensure_dir

def download_movielens_100k(url: str, local_dir: str) -> str:
    """ä¸‹è½½ MovieLens-100K u.data åˆ°æœ¬åœ°ã€‚

    ä¸­æ–‡æ³¨é‡Šï¼šå·¥ä¸šè½åœ°å¯åšæ–­ç‚¹ç»­ä¼ ã€MD5 æ ¡éªŒã€é‡è¯•ç­–ç•¥ç­‰ã€‚
    """
    ensure_dir(local_dir)
    local_path = os.path.join(local_dir, "u.data")
    if os.path.exists(local_path):
        logger.info(f"Found cached dataset at: {local_path}")
        return local_path

    logger.info(f"Downloading dataset from {url} ...")
    resp = requests.get(url, timeout=60)
    resp.raise_for_status()
    with open(local_path, "wb") as f:
        f.write(resp.content)
    logger.info(f"Saved to {local_path}")
    return local_path

def load_movielens_100k(local_path: str) -> pd.DataFrame:
    """è¯»å– u.data ä¸º DataFrame: user_id, item_id, rating, timestamp"""
    df = pd.read_csv(
        local_path,
        sep="\t",
        header=None,
        names=["user_id", "item_id", "rating", "timestamp"],
        engine="python",
    )
    return df
```

* * *

8) `src/preprocessing.py`
-------------------------

```python
from __future__ import annotations

from typing import Dict, Tuple, List
from loguru import logger
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split

def binarize_interactions(
    df: pd.DataFrame, threshold: int
) -> pd.DataFrame:
    """è¯„åˆ†äºŒå€¼åŒ–ï¼ˆâ‰¥threshold è§†ä¸ºæ­£åé¦ˆï¼‰ã€‚

    Returns:
        ä»…åŒ…å«æ­£åé¦ˆçš„ (user_id, item_id, ts)ã€‚
    """
    df_pos = df[df["rating"] >= threshold].copy()
    df_pos = df_pos[["user_id", "item_id", "timestamp"]]
    df_pos.sort_values(["user_id", "timestamp"], inplace=True)
    return df_pos

def filter_cold_users_items(
    df_pos: pd.DataFrame,
    min_inter_per_user: int,
    min_user_per_item: int,
) -> pd.DataFrame:
    """è¿‡æ»¤å†·ç”¨æˆ·/å†·ç‰©å“ä»¥æå‡ç¨³å®šæ€§ä¸è®­ç»ƒè´¨é‡ã€‚"""
    # å…ˆæŒ‰ç”¨æˆ·è¿‡æ»¤
    user_cnt = df_pos.groupby("user_id")["item_id"].nunique()
    keep_users = set(user_cnt[user_cnt >= min_inter_per_user].index)
    df_pos = df_pos[df_pos["user_id"].isin(keep_users)]

    # å†æŒ‰ç‰©å“è¿‡æ»¤
    item_cnt = df_pos.groupby("item_id")["user_id"].nunique()
    keep_items = set(item_cnt[item_cnt >= min_user_per_item].index)
    df_pos = df_pos[df_pos["item_id"].isin(keep_items)]

    return df_pos

def train_test_random_split(
    df_pos: pd.DataFrame, test_ratio: float, seed: int
) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """ç®€å•éšæœºåˆ‡åˆ†ï¼ˆå·¥ä¸šå®è·µä¸­å¯åš leave-one-out by timeï¼‰ã€‚"""
    train_df, test_df = train_test_split(
        df_pos, test_size=test_ratio, random_state=seed, shuffle=True
    )
    # ä¿è¯ç”¨æˆ·åœ¨è®­ç»ƒé›†ä¸­å‡ºç°ï¼ˆè¯„ä¼°éœ€è¦ï¼‰
    seen_users = set(train_df["user_id"])
    test_df = test_df[test_df["user_id"].isin(seen_users)]
    return train_df, test_df

def build_mappings(
    df_pos: pd.DataFrame,
) -> Tuple[Dict[int, int], Dict[int, int], Dict[int, int], Dict[int, int]]:
    """æ„å»ºç¨ å¯†æ˜ å°„ï¼šuser/item åŸå§‹id -> è¿ç»­idï¼ˆ0..n-1ï¼‰

    Returns:
        uid2idx, idx2uid, iid2idx, idx2iid
    """
    uniq_users = sorted(df_pos["user_id"].unique().tolist())
    uniq_items = sorted(df_pos["item_id"].unique().tolist())

    uid2idx = {u: i for i, u in enumerate(uniq_users)}
    idx2uid = {i: u for i, u in enumerate(uniq_users)}
    iid2idx = {m: j for j, m in enumerate(uniq_items)}
    idx2iid = {j: m for j, m in enumerate(uniq_items)}
    return uid2idx, idx2uid, iid2idx, idx2iid

def remap_ids(
    df: pd.DataFrame,
    uid2idx: Dict[int, int],
    iid2idx: Dict[int, int],
) -> pd.DataFrame:
    """æŠŠåŸå§‹ user/item id æ˜ å°„åˆ°è¿ç»­ç´¢å¼•ï¼Œä¾¿äºé«˜æ•ˆè®¡ç®—ã€‚"""
    out = df.copy()
    out["user_idx"] = out["user_id"].map(uid2idx)
    out["item_idx"] = out["item_id"].map(iid2idx)
    out = out.dropna(subset=["user_idx", "item_idx"]).astype({"user_idx": int, "item_idx": int})
    return out

def build_user_item_sets(
    df_train: pd.DataFrame
) -> Tuple[Dict[int, List[int]], Dict[int, List[int]]]:
    """æ„å»º userâ†’items ä¸ itemâ†’users çš„å€’æ’ç´¢å¼•ï¼ˆåˆ—è¡¨ï¼‰ã€‚

    è¿”å›:
        user_items: {user_idx: [item_idx, ...]}
        item_users: {item_idx: [user_idx, ...]}
    """
    user_items: Dict[int, List[int]] = {}
    item_users: Dict[int, List[int]] = {}

    for r in df_train[["user_idx", "item_idx"]].itertuples(index=False):
        u = int(r.user_idx)
        i = int(r.item_idx)
        user_items.setdefault(u, []).append(i)
        item_users.setdefault(i, []).append(u)

    # å»é‡ & æ’åºï¼Œä¾¿äºåç»­äº¤é›†æ“ä½œ
    for u in user_items:
        user_items[u] = sorted(set(user_items[u]))
    for i in item_users:
        item_users[i] = sorted(set(item_users[i]))

    logger.info(f"user_items size: {len(user_items)}, item_users size: {len(item_users)}")
    return user_items, item_users
```

* * *

9) `src/swing.py`
-----------------

```python
from __future__ import annotations

from typing import Dict, List, Tuple, DefaultDict
from collections import defaultdict
from loguru import logger
from tqdm import tqdm

from .utils import dict_topk

class SwingCFIndexer:
    """Swing ç´¢å¼•ä¸ç›¸ä¼¼åº¦è®¡ç®—å™¨ã€‚

    æ ¸å¿ƒå…¬å¼ï¼ˆå«å¯¹è§’ï¼‰ï¼š
        sim(i, j) = sum_{u in V} sum_{v in V} 1 / (alpha + overlap(u, v))
    å…¶ä¸­:
        V = users(i) âˆ© users(j)
        overlap(u, v) = | items(u) âˆ© items(v) |
    """

    def __init__(
        self,
        alpha: float = 1.0,
        max_user_per_item: int = 200,
        topk_sim: int = 200,
    ) -> None:
        """
        Args:
            alpha: Swing åˆ†æ¯å¹³æ»‘/æƒ©ç½šå¼ºåº¦ã€‚
            max_user_per_item: é™åˆ¶æ¯ä¸ªç‰©å“ç”¨äºæ„å›¾çš„ç”¨æˆ·æ•°ç›®ä¸Šé™ï¼ˆæ§åˆ¶å¤æ‚åº¦ï¼‰ã€‚
            topk_sim: æ¯ä¸ªç‰©å“ä¿ç•™çš„ç›¸ä¼¼é‚»å±…æ•°é‡ï¼ˆç¨€ç–åŒ–ç›¸ä¼¼åº¦çŸ©é˜µï¼‰ã€‚
        """
        assert alpha > 0.0, "alpha å¿…é¡» > 0"
        assert max_user_per_item > 1, "max_user_per_item å¿…é¡» > 1"
        assert topk_sim >= 1, "topk_sim å¿…é¡» >= 1"

        self.alpha = alpha
        self.max_user_per_item = max_user_per_item
        self.topk_sim = topk_sim

        # è¾“å…¥ç´¢å¼•
        self.user_items: Dict[int, List[int]] = {}
        self.item_users: Dict[int, List[int]] = {}

        # é¢„è®¡ç®—çš„ç”¨æˆ·-ç”¨æˆ· overlapï¼ˆå«å¯¹è§’ï¼‰
        self.user_overlap: Dict[int, Dict[int, int]] = {}

        # ç¨€ç–ç›¸ä¼¼åº¦çŸ©é˜µï¼šitem->(item->score)
        self.item_sims: Dict[int, Dict[int, float]] = {}

    # ------------------------- å…¬å…±æ¥å£ -------------------------

    def fit(
        self,
        user_items: Dict[int, List[int]],
        item_users: Dict[int, List[int]],
    ) -> "SwingCFIndexer":
        """ä¸»å…¥å£ï¼šæ„å»º user-user overlap, è®¡ç®— Swing ç›¸ä¼¼åº¦ï¼Œå¹¶ç¨€ç–åŒ–ã€‚

        ä¸­æ–‡æ³¨é‡Šï¼šè¯¥è¿‡ç¨‹å¯¹å¤æ‚åº¦è¾ƒæ•æ„Ÿï¼Œç”Ÿäº§ä¸­éœ€ç»“åˆé‡‡æ ·/åˆ†æ¡¶/å¹¶è¡Œä¼˜åŒ–ã€‚
        """
        self.user_items = user_items
        self.item_users = item_users

        self._build_user_overlap()
        self._build_item_sims()
        self._keep_topk()
        return self

    def get_item_sims(self) -> Dict[int, Dict[int, float]]:
        """è¿”å›ç¨€ç–ç›¸ä¼¼åº¦çŸ©é˜µã€‚"""
        return self.item_sims

    # ------------------------- å†…éƒ¨æ–¹æ³• -------------------------

    def _build_user_overlap(self) -> None:
        """é¢„è®¡ç®—ç”¨æˆ·ä¸¤ä¸¤çš„ overlap = |J_u âˆ© J_v|ï¼Œå«å¯¹è§’ (u,u)=|J_u|ã€‚"""
        logger.info("Building user-user overlap ...")
        overlap: DefaultDict[int, Dict[int, int]] = defaultdict(dict)

        # 1) å¯¹è§’é¡¹ï¼ˆè‡ªèº«ä¸è‡ªèº«çš„é‡åˆåº¦ = å–œæ¬¢çš„ç‰©å“æ•°ï¼‰
        for u, items in self.user_items.items():
            overlap[u][u] = len(items)

        # 2) å…±ç°é¡¹ï¼šå¯¹æ¯ä¸ªç‰©å“ï¼ŒæŠŠå…¶ç”¨æˆ·ä¸¤ä¸¤é…å¯¹ï¼ˆä¸Šä¸‰è§’ï¼‰è®¡æ•° +1
        for i, users in tqdm(self.item_users.items(), desc="overlap by cooccurrence"):
            # æ§åˆ¶å¤æ‚åº¦ï¼šæˆªæ–­è¶…å¤§ç‰©å“çš„ç”¨æˆ·åˆ—è¡¨
            if len(users) > self.max_user_per_item:
                users = users[: self.max_user_per_item]

            # ä¸Šä¸‰è§’ä¸¤ä¸¤è®¡æ•°
            for idx_a in range(len(users)):
                ua = users[idx_a]
                for idx_b in range(idx_a + 1, len(users)):
                    ub = users[idx_b]
                    # å¯¹ç§°å¡«å……
                    va = overlap[ua].get(ub, 0) + 1
                    overlap[ua][ub] = va
                    overlap[ub][ua] = va

        self.user_overlap = dict(overlap)
        logger.info(f"user_overlap entries (approx pairs): {sum(len(v) for v in self.user_overlap.values())}")

    def _build_item_sims(self) -> None:
        """è®¡ç®—ç‰©å“ä¸¤ä¸¤ Swing ç›¸ä¼¼åº¦ï¼ˆç¨€ç–å­˜å‚¨ï¼‰ã€‚"""
        logger.info("Building item-item swing similarities ...")
        item_ids = sorted(self.item_users.keys())
        sims: DefaultDict[int, Dict[int, float]] = defaultdict(dict)

        for idx_a in tqdm(range(len(item_ids)), desc="item swing sim"):
            ia = item_ids[idx_a]
            users_a = self.item_users[ia]
            if len(users_a) > self.max_user_per_item:
                users_a = users_a[: self.max_user_per_item]
            # ä½¿ç”¨é‚»åŸŸï¼šåªä¸æœ‰äº¤é›†çš„ç‰©å“è®¡ç®—
            # å€ŸåŠ© "ç”¨æˆ·â†’æ‰€äº¤äº’ç‰©å“" åæŸ¥ï¼Œæ„å»ºå€™é€‰ç‰©å“é›†åˆ
            neighbor_items = set()
            for u in users_a:
                neighbor_items.update(self.user_items[u])

            for ib in neighbor_items:
                if ib <= ia:
                    continue  # ä¸Šä¸‰è§’é¿å…é‡å¤
                users_b = self.item_users.get(ib, [])
                if not users_b:
                    continue
                if len(users_b) > self.max_user_per_item:
                    users_b = users_b[: self.max_user_per_item]

                # V = users(ia) âˆ© users(ib)
                V = intersect_sorted(users_a, users_b)
                if len(V) == 0:
                    continue

                score = 0.0
                # åŒå±‚åµŒå¥—ï¼ˆå«å¯¹è§’ï¼‰ï¼Œå¯ç”¨ä¸Šä¸‰è§’*2+å¯¹è§’åŠ é€Ÿ
                for x in range(len(V)):
                    ux = V[x]
                    # å¯¹è§’
                    overlap_xx = self.user_overlap[ux].get(ux, 0)
                    score += 1.0 / (self.alpha + float(overlap_xx))
                    # ä¸Šä¸‰è§’
                    for y in range(x + 1, len(V)):
                        uy = V[y]
                        ov = self.user_overlap[ux].get(uy, 0)
                        val = 1.0 / (self.alpha + float(ov))
                        score += 2.0 * val  # å¯¹ç§° (ux,uy) ä¸ (uy,ux)

                if score > 0.0:
                    sims[ia][ib] = score
                    sims[ib][ia] = score  # ä¿æŒå¯¹ç§°

        self.item_sims = dict(sims)

    def _keep_topk(self) -> None:
        """å¯¹æ¯ä¸ªç‰©å“çš„ç›¸ä¼¼é‚»å±…åš top-k æˆªæ–­ï¼Œä¿æŒçŸ©é˜µç¨€ç–ã€‚"""
        if self.topk_sim <= 0:
            return
        for i in list(self.item_sims.keys()):
            self.item_sims[i] = dict_topk(self.item_sims[i], self.topk_sim)

def intersect_sorted(a: List[int], b: List[int]) -> List[int]:
    """ä¸¤ä¸ªå‡åºåˆ—è¡¨çš„äº¤é›†ï¼ˆçº¿æ€§æŒ‡é’ˆæ³•ï¼‰ï¼Œè¿”å›å‡åºæ— é‡å¤åˆ—è¡¨ã€‚"""
    i, j = 0, 0
    out: List[int] = []
    while i < len(a) and j < len(b):
        if a[i] == b[j]:
            if not out or out[-1] != a[i]:
                out.append(a[i])
            i += 1
            j += 1
        elif a[i] < b[j]:
            i += 1
        else:
            j += 1
    return out
```

* * *

10) `src/recall.py`
-------------------

```python
from __future__ import annotations

from typing import Dict, List, Tuple
from loguru import logger
import numpy as np

class SwingRecommender:
    """åŸºäº Swing ç›¸ä¼¼åº¦çŸ©é˜µçš„æ‰“åˆ†ä¸å¬å›å™¨ã€‚"""

    def __init__(
        self,
        item_sims: Dict[int, Dict[int, float]],
        user_items: Dict[int, List[int]],
        exclude_seen: bool = True,
    ) -> None:
        """
        Args:
            item_sims: ç¨€ç–ç›¸ä¼¼åº¦çŸ©é˜µ {item_i: {item_j: sim_ij}}
            user_items: ç”¨æˆ·â†’å·²äº¤äº’ç‰©å“
            exclude_seen: æ˜¯å¦åœ¨å¬å›ä¸­æ’é™¤å·²äº¤äº’ç‰©å“
        """
        self.item_sims = item_sims
        self.user_items = user_items
        self.exclude_seen = exclude_seen

    def recommend_for_user(
        self, user: int, topk: int = 50
    ) -> List[Tuple[int, float]]:
        """å¯¹å•ä¸ªç”¨æˆ·è¿›è¡Œå¬å›ï¼Œè¿”å› (item, score) çš„é™åºåˆ—è¡¨ã€‚"""
        seen = set(self.user_items.get(user, []))
        scores: Dict[int, float] = {}

        # åŸºäºç”¨æˆ·å·²çœ‹ç‰©å“çš„ç›¸ä¼¼é‚»å±…è¿›è¡Œç´¯åŠ æ‰“åˆ†
        for i in self.user_items.get(user, []):
            for j, s in self.item_sims.get(i, {}).items():
                if self.exclude_seen and j in seen:
                    continue
                scores[j] = scores.get(j, 0.0) + s

        if not scores:
            return []

        # topk
        items = list(scores.items())
        items.sort(key=lambda x: x[1], reverse=True)
        return items[:topk]

    def batch_recommend(
        self, users: List[int], topk: int = 50
    ) -> Dict[int, List[Tuple[int, float]]]:
        """æ‰¹é‡å¬å›ã€‚"""
        out = {}
        for u in users:
            out[u] = self.recommend_for_user(u, topk=topk)
        return out
```

* * *

11) `src/metrics.py`
--------------------

```python
from __future__ import annotations

from typing import Dict, List, Tuple
import numpy as np

def recall_at_k(
    recs: Dict[int, List[int]], ground_truth: Dict[int, List[int]], k: int
) -> float:
    """Recall@Kï¼šå‘½ä¸­ç‡ã€‚
    Args:
        recs: {user: [item...]}ï¼ˆé¢„æµ‹ï¼‰
        ground_truth: {user: [item...]}ï¼ˆçœŸå®ï¼‰
    """
    users = [u for u in recs if u in ground_truth]
    if not users:
        return 0.0
    hit = 0
    total = 0
    for u in users:
        pred = set(recs[u][:k])
        gt = set(ground_truth[u])
        if len(gt) == 0:
            continue
        hit += len(pred & gt)
        total += len(gt)
    return (hit / total) if total > 0 else 0.0

def average_precision_at_k(pred: List[int], gt: List[int], k: int) -> float:
    """AP@K for a single user."""
    if not gt:
        return 0.0
    gt_set = set(gt)
    hits = 0
    sum_prec = 0.0
    for i, item in enumerate(pred[:k], start=1):
        if item in gt_set:
            hits += 1
            sum_prec += hits / i
    return sum_prec / min(len(gt), k)

def map_at_k(
    recs: Dict[int, List[int]], ground_truth: Dict[int, List[int]], k: int
) -> float:
    """MAP@K."""
    users = [u for u in recs if u in ground_truth]
    if not users:
        return 0.0
    vals = []
    for u in users:
        vals.append(average_precision_at_k(recs[u], ground_truth[u], k))
    return float(np.mean(vals)) if vals else 0.0

def ndcg_at_k(
    recs: Dict[int, List[int]], ground_truth: Dict[int, List[int]], k: int
) -> float:
    """NDCG@K (äºŒå€¼ç›¸å…³æ€§)ã€‚"""
    def dcg(rel: List[int]) -> float:
        return sum((1.0 / np.log2(i + 2) for i, r in enumerate(rel) if r > 0))

    users = [u for u in recs if u in ground_truth]
    if not users:
        return 0.0
    vals = []
    for u in users:
        gt = set(ground_truth[u])
        rel = [1 if it in gt else 0 for it in recs[u][:k]]
        ideal = sorted(rel, reverse=True)
        denom = dcg(ideal)
        vals.append((dcg(rel) / denom) if denom > 0 else 0.0)
    return float(np.mean(vals)) if vals else 0.0
```

* * *

12) `src/main.py`
-----------------

```python
from __future__ import annotations

import argparse
from typing import Dict, List
from loguru import logger
import numpy as np
import pandas as pd

from .utils import setup_logger, set_seed
from .config import Cfg
from .data import download_movielens_100k, load_movielens_100k
from .preprocessing import (
    binarize_interactions,
    filter_cold_users_items,
    train_test_random_split,
    build_mappings,
    remap_ids,
    build_user_item_sets,
)
from .swing import SwingCFIndexer
from .recall import SwingRecommender
from .metrics import recall_at_k, map_at_k, ndcg_at_k

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser()
    parser.add_argument("--config", type=str, default="config.yaml")
    return parser.parse_args()

def df_to_gt(test_df: pd.DataFrame) -> Dict[int, List[int]]:
    """æŠŠæµ‹è¯•é›†è½¬ä¸º {user_idx: [item_idx,...]} ä½œä¸º ground truthã€‚"""
    gt: Dict[int, List[int]] = {}
    for r in test_df[["user_idx", "item_idx"]].itertuples(index=False):
        gt.setdefault(int(r.user_idx), []).append(int(r.item_idx))
    return gt

def main() -> None:
    setup_logger()
    args = parse_args()
    cfg = Cfg.from_yaml(args.config)
    set_seed(cfg.random_seed)

    # ---------------- æ•°æ®å‡†å¤‡ ----------------
    logger.info("=== Stage 1: Download & Load Dataset ===")
    path = download_movielens_100k(cfg.dataset.url, cfg.dataset.local_dir)
    raw = load_movielens_100k(path)
    logger.info(f"Raw shape: {raw.shape}")

    logger.info("=== Stage 2: Binarize & Filter ===")
    df_pos = binarize_interactions(raw, cfg.dataset.binarize_threshold)
    df_pos = filter_cold_users_items(
        df_pos,
        cfg.dataset.min_inter_per_user,
        cfg.dataset.min_user_per_item,
    )
    logger.info(f"Positive interactions after filter: {df_pos.shape}")

    logger.info("=== Stage 3: Train/Test Split ===")
    train_df, test_df = train_test_random_split(
        df_pos, cfg.dataset.test_ratio, cfg.random_seed
    )
    logger.info(f"Train: {train_df.shape}, Test: {test_df.shape}")

    logger.info("=== Stage 4: Build ID Mappings ===")
    uid2idx, idx2uid, iid2idx, idx2iid = build_mappings(train_df)
    train_df = remap_ids(train_df, uid2idx, iid2idx)
    test_df = remap_ids(test_df, uid2idx, iid2idx)
    logger.info(f"Users: {len(uid2idx)}, Items: {len(iid2idx)}")

    logger.info("=== Stage 5: Build Inverted Index ===")
    user_items, item_users = build_user_item_sets(train_df)

    # ---------------- ç´¢å¼•ä¸ç›¸ä¼¼åº¦ ----------------
    logger.info("=== Stage 6: Swing Indexing & Similarity ===")
    indexer = SwingCFIndexer(
        alpha=cfg.swing.alpha,
        max_user_per_item=cfg.swing.max_user_per_item,
        topk_sim=cfg.swing.topk_sim,
    ).fit(user_items=user_items, item_users=item_users)

    item_sims = indexer.get_item_sims()
    # å…³é”®è‡ªæ£€ï¼šç›¸ä¼¼åº¦å¯¹ç§°æ€§ä¸éè´Ÿæ€§
    _sanity_check_item_sims(item_sims)

    # ---------------- å¬å›ä¸è¯„ä¼° ----------------
    logger.info("=== Stage 7: Recall & Evaluate ===")
    recommender = SwingRecommender(
        item_sims=item_sims,
        user_items=user_items,
        exclude_seen=cfg.recall.exclude_seen,
    )

    users_eval = sorted(set(test_df["user_idx"].unique().tolist()))
    rec_pred = {}
    for u in users_eval:
        recs = recommender.recommend_for_user(u, topk=cfg.recall.k_recall)
        rec_pred[u] = [it for it, _ in recs]

    gt = df_to_gt(test_df)

    for k in cfg.evaluate.ks:
        r = recall_at_k(rec_pred, gt, k)
        m = map_at_k(rec_pred, gt, k)
        n = ndcg_at_k(rec_pred, gt, k)
        logger.info(f"[Eval] K={k:>3d}  Recall={r:.4f}  MAP={m:.4f}  NDCG={n:.4f}")

    # ---------------- ç»“æœå±•ç¤ºï¼ˆæ ·ä¾‹ï¼‰ ----------------
    sample_users = users_eval[:5]
    for u in sample_users:
        recs = recommender.recommend_for_user(u, topk=10)
        logger.info(f"[Sample] user={u}, recs={recs}")

    logger.info("Pipeline finished.")

def _sanity_check_item_sims(item_sims: Dict[int, Dict[int, float]]) -> None:
    """å…³é”®ä¸€è‡´æ€§è‡ªæ£€ï¼šå¯¹ç§°ã€éè´Ÿã€æ— è‡ªç¯ï¼ˆå¦‚éœ€è¦ï¼‰ã€‚"""
    cnt = 0
    for i, neigh in item_sims.items():
        for j, s in neigh.items():
            assert s >= 0.0, "ç›¸ä¼¼åº¦å¿…é¡»éè´Ÿ"
            # å¯¹ç§°æ€§
            s2 = item_sims.get(j, {}).get(i, None)
            assert s2 is not None and abs(s - s2) < 1e-8, "ç›¸ä¼¼åº¦çŸ©é˜µéœ€è¦å¯¹ç§°"
            cnt += 1
    logger.info(f"Sanity check passed. checked edges={cnt}")

if __name__ == "__main__":
    main()
```

* * *

ä¸‰ã€å¦‚ä½•è¿è¡Œï¼ˆç®€è¦ï¼‰
==========

```bash
pip install -r requirements.txt
python -m src.main --config config.yaml
```

è¿è¡Œåæ—¥å¿—å°†ä¾æ¬¡æ‰“å°ï¼šæ•°æ®ä¸‹è½½â†’è¿‡æ»¤â†’åˆ‡åˆ†â†’ç´¢å¼•â†’Swing ç›¸ä¼¼åº¦æ„å»ºâ†’TopK æˆªæ–­â†’å¬å›â†’è¯„ä¼°ï¼ˆRecall/MAP/NDCGï¼‰â†’æ ·ä¾‹ç”¨æˆ·æ¨èç»“æœã€‚

* * *

å››ã€å·¥ç¨‹è¦ç‚¹ & å¤æ‚åº¦æ§åˆ¶ï¼ˆå®æˆ˜å¿ƒå¾—ï¼‰
====================

*   **å¤æ‚åº¦ç“¶é¢ˆ**ï¼šSwing çš„åŒå±‚ç”¨æˆ·æ±‚å’Œåœ¨ VÃ—V ä¸Šï¼ŒV=å…±åŒç”¨æˆ·é›†åˆã€‚é€šè¿‡
    *   `max_user_per_item` é™åˆ¶æ¯ä¸ªç‰©å“å‚ä¸æ„å›¾çš„ç”¨æˆ·æ•°ï¼›
    *   ç›¸ä¼¼åº¦è®¡ç®—æ—¶ä»…å¯¹ **å­˜åœ¨äº¤é›†çš„å€™é€‰ç‰©å“** è®¡ç®—ï¼ˆé‚»åŸŸæ³•ï¼‰ï¼›
    *   `topk_sim` ç¨€ç–åŒ–é‚»å±…ï¼Œä¿æŒçŸ©é˜µç¨€ç–ã€‚
*   **ç¨³å®šæ€§**ï¼šè¿‡æ»¤å†·ç”¨æˆ·/å†·ç‰©å“ï¼Œå‡å°‘å™ªå£°ï¼›äºŒå€¼åŒ–é˜ˆå€¼å¯æŒ‰ä¸šåŠ¡è°ƒã€‚
*   **æ­£ç¡®æ€§è‡ªæ£€**ï¼šå¯¹ç§°æ€§ã€éè´Ÿæ€§æ–­è¨€ï¼›å¯è¿½åŠ éšæœºæŠ½æ ·é‡ç®—æ ¸å¯¹ã€‚
*   **å¯æ‰©å±•æ–¹å‘**ï¼š
    *   å°† `user_overlap` ä¸ `item_sims` çš„æ„å»ºå¹¶è¡ŒåŒ–/æ‰¹å¤„ç†åŒ–ï¼›
    *   é‡‡ç”¨åˆ†æ¡¶ï¼ˆæŒ‰æ´»è·ƒåº¦/æ—¶é—´ï¼‰åšåˆ†æ²»ï¼›
    *   æ”¯æŒå¢é‡æ›´æ–°ï¼ˆæ–°äº¤äº’åˆ°æ¥æ—¶ä»…æ›´æ–°ç›¸å…³å¯¹ï¼‰ã€‚

* * *

å¦‚æœä½ å¸Œæœ›ï¼Œæˆ‘å¯ä»¥ç»§ç»­è¡¥å……ï¼š

*   å¸¦ **leave-one-out by time** çš„è¯„ä¼°åˆ‡åˆ†ç‰ˆæœ¬ï¼›
*   æ›´æ¿€è¿›çš„æ€§èƒ½ä¼˜åŒ–ï¼ˆå¤šè¿›ç¨‹ / numba / åˆ†æ¡¶ç¨€ç– CSR å®ç°ï¼‰ï¼›
*   ä¸ **ItemCF/Graph CF** å¹¶è¡Œå¯¹æ¯”è¯„æµ‹è„šæœ¬ï¼Œå¸®åŠ©ä½ åšç­–ç•¥å¯¹æ¯”ä¸ A/Bã€‚



---
Powered by [ChatGPT Exporter](https://www.chatgptexporter.com)